/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package event.alert.demo;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.functions.RichFlatMapFunction;
import org.apache.flink.api.common.serialization.SimpleStringSchema;
import org.apache.flink.api.common.state.BroadcastState;
import org.apache.flink.api.common.state.MapStateDescriptor;
import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.connector.kafka.source.KafkaSource;
import org.apache.flink.connector.kafka.source.enumerator.initializer.OffsetsInitializer;
import org.apache.flink.formats.json.JsonDeserializationSchema;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.flink.streaming.api.datastream.BroadcastConnectedStream;
import org.apache.flink.streaming.api.datastream.BroadcastStream;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.co.BroadcastProcessFunction;
import org.apache.flink.streaming.api.functions.co.KeyedBroadcastProcessFunction;
import org.apache.flink.table.api.bridge.java.StreamTableEnvironment;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;

public class Main {
    
	public static void main(String[] args) throws Exception {
		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
		
		JsonDeserializationSchema<Sensor> sensorSchema = new JsonDeserializationSchema<>(Sensor.class);
		JsonDeserializationSchema<Rule> ruleSchema = new JsonDeserializationSchema<>(Rule.class);
		
		KafkaSource<Sensor> sensorSource = KafkaSource.<Sensor>builder()
				.setBootstrapServers("192.168.1.120:9092")
				.setTopics("sensor-topic")
				.setGroupId("myGroup")
				.setStartingOffsets(OffsetsInitializer.earliest())
				.setValueOnlyDeserializer(sensorSchema)
				.build();
		
		KafkaSource<Rule> ruleSource = KafkaSource.<Rule>builder()
				.setBootstrapServers("192.168.1.120:9092")
				.setTopics("rule-topic")
				.setGroupId("myGroup")
				.setStartingOffsets(OffsetsInitializer.earliest())
				.setValueOnlyDeserializer(ruleSchema)
				.build();
		
		DataStream<Sensor> sensorStream = env.fromSource(sensorSource, WatermarkStrategy.noWatermarks(), "sensor");
		DataStream<Rule> prevRuleStream = env.fromSource(ruleSource, WatermarkStrategy.noWatermarks(), "rule").setParallelism(1);

		BroadcastStream<Rule> ruleStream = prevRuleStream.broadcast(Descriptors.rulesDescriptor);
		
		sensorStream.print();
		prevRuleStream.print();
		
//		<Sensor, Rule> bcs =
//				sensorStream.keyBy(v -> v.getDeviceId()).connect(ruleStream);
		
		DataStream<Alert> alertStream =
				sensorStream
					.keyBy(v -> v.getDeviceId())
					.connect(ruleStream)
					.process(new DynamicFunction2());
		
		alertStream.print();
		
//		stream.print();
//		DataStream<Sensor> sensorStream = stream
//				.flatMap(new JsonDeserializer<Sensor>(Sensor.class))
//				.returns(Sensor.class).name("Sensor Deserialization");
//		
//		sensorStream.print();
		
		env.execute();
	}
	
	public static class Descriptors {
	    public static final MapStateDescriptor<Integer, Rule> rulesDescriptor =
	        new MapStateDescriptor<>(
	            "rules", BasicTypeInfo.INT_TYPE_INFO, TypeInformation.of(Rule.class));
	}
}

@Data
class Sensor {
	private String deviceId;
	private String deviceName;
	private String serialNumber;
	private String timeStamp;
	private HashMap<String, String> dataProps;
}

@Data
class Rule {
	private Integer ruleId;
	private String ruleName;
	private List<RuleCond> ruleSet;
}

@Data
class Alert {
	private String message;
}

@Data
class RuleCond {
	private String target;
	private String operator;
	private Integer limit;
	private String next;
}

class AlertFunction {
	
}

class DynamicFunction2 extends KeyedBroadcastProcessFunction<Integer, Sensor, Rule, Alert> {

	@Override
	public void processBroadcastElement(Rule rule,
			KeyedBroadcastProcessFunction<Integer, Sensor, Rule, Alert>.Context context, Collector<Alert> arg2)
			throws Exception {
		System.out.println(
				"processBroadcastElement : " +
				rule.toString() + " " +
				context.currentProcessingTime()
				);
	}

	@Override
	public void processElement(Sensor sensor,
			KeyedBroadcastProcessFunction<Integer, Sensor, Rule, Alert>.ReadOnlyContext context, Collector<Alert> arg2)
			throws Exception {
		System.out.println(
				"processElement : " + 
				sensor.toString() + " " +
				context.currentProcessingTime()
				);
		
	}
	
}

class DynamicFunction extends BroadcastProcessFunction<Sensor, Rule, Alert> {

	@Override
	public void processElement(
			Sensor sensor,
			BroadcastProcessFunction<Sensor, Rule, Alert>.ReadOnlyContext context,
			Collector<Alert> out) throws Exception {
		System.out.println(
				"processElement : " + 
				sensor.toString() + " " +
				context.currentProcessingTime()
				);
	}
	
	@Override
	public void processBroadcastElement(
			Rule rule,
			BroadcastProcessFunction<Sensor, Rule, Alert>.Context context,
			Collector<Alert> out) throws Exception {
		
		BroadcastState<Integer, Rule> broadcastState = context.getBroadcastState(Main.Descriptors.rulesDescriptor);
		broadcastState.put(rule.getRuleId(), rule);
		
		System.out.println(
				"processBroadcastElement : " +
				rule.toString() + " " +
				context.currentProcessingTime()
				);
	}
}

class JsonDeserializer<T> extends RichFlatMapFunction<String, T> {
	private JsonMapper<T> parser;
	private Class<T> targetClass;
	
	public JsonDeserializer(Class<T> targetClass) {
		this.targetClass = targetClass;
	}
	
	@Override
	public void open(Configuration parameters) throws Exception {
		super.open(parameters);
		parser = new JsonMapper<>(targetClass);
	}

	@Override
	public void flatMap(String value, Collector<T> out) throws Exception {
		try {
			T parsed = parser.fromString(value);
			out.collect(parsed);
		} catch (Exception e) {
			System.out.println(e);
		}
	}
	
}

class JsonMapper<T> {
	
	private Class<T> targetClass;
	private ObjectMapper objectMapper;
	
	public JsonMapper(Class<T> targetClass) {
		this.targetClass = targetClass;
		objectMapper = new ObjectMapper();
	}
	
	public T fromString(String line) throws IOException {
		return objectMapper.readValue(line, targetClass);
	}
	
	public String toString(T line) throws IOException {
		return objectMapper.writeValueAsString(line);
	}
}

enum Type {
	KAFKA,
	PUBSUB,
	SOCKET;
}